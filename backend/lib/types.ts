import { User } from "sso";
import type {
    GroupId,
    JsonSafe,
    Message,
    RecordingId,
    RoomId,
    UserId,
} from "./database.js";

export type UUID = ReturnType<typeof crypto.randomUUID>;
export type Email = `${string}@${string}.${string}`;
export type SignalId = `signal:${UUID}`;

const emailRegex = /^[^\s@]+@[^\s@.]+\.[^\s@]+$/;

export function isEmail(email: string): email is Email {
    return emailRegex.test(email);
}

export function assertEmail(email: string): asserts email is Email {
    if (!isEmail(email))
        throw new Error(`Expected an email. Got ${JSON.stringify(email)}`);
}

/** A regex which matches v4 UUIDs */
const uuidRegex =
    /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;

/** Check a string is a valid UUID */
export function isUUID(uuid: string): uuid is UUID {
    return uuidRegex.test(uuid);
}

export function isSignalId(id: string): id is SignalId {
    return id.startsWith("signal:");
}

export type RecordingEvent = (arg: {
    action: "start" | "stop";
    from: UUID;
}) => void;

export interface RoomServerToClientEvents {
    signal: (arg: {
        from: SignalId;
        desc?: RTCSessionDescription | null;
        candidate?: RTCIceCandidate | null;
    }) => void;
    connect_to: (arg: { id: UUID; polite: boolean }) => void;
    disconnect_from: (arg: { id: UUID }) => void;
    recording: RecordingEvent;
}

export interface RoomClientToServerEvents {
    signal: (arg: {
        to: SignalId;
        desc?: RTCSessionDescription | null;
        candidate?: RTCIceCandidate | null;
    }) => void;
    join_room: (id: JsonSafe<RoomId>) => void;
    leave_room: () => void;
    recording: RecordingEvent;

    upload_start: (
        arg: { mimeType: string },
        callback: (
            arg:
                | { id: JsonSafe<RecordingId>; error?: never }
                | { id?: never; error: string }
        ) => void
    ) => void;
    upload_chunk: (id: JsonSafe<RecordingId>, data: ArrayBuffer) => void;
    upload_stop: (id: JsonSafe<RecordingId>) => void;
}

export interface MessageServerToClientEvents {
    /** Some messages from the server */
    messages: (ms: JsonSafe<Message>[]) => void;

    /** Information about some users */
    users: (us: { id: JsonSafe<UserId>; name: string }[]) => void;
}

export interface MessageClientToServerEvents {
    /** Subscribe to messages on a group */
    subscribe: (id: JsonSafe<GroupId>) => void;

    /** Request older messages from a group */
    request_messages: () => void;

    /** Request information about some users */
    request_users: (ids: JsonSafe<UserId>[]) => void;

    /** Send a message */
    send: (
        arg: { groupId: JsonSafe<GroupId>; content: string; msgId: UUID },
        ack: () => void
    ) => void;
}

export interface InterServerEvents {}

export interface SocketData {
    /** Information about the user */
    user?: Omit<User, "id"> & { id: UserId };

    /** A UUID assigned to this user for the sake of signalling */
    signalId?: SignalId;
    /** The user's name */
    userName?: string;
    /** The id of the room the user is connected to */
    roomId?: RoomId;
}

export interface RoomSocketData extends SocketData {
    /** Which messages have been seen? Using client generated UUIDs */
    seenMessages?: Set<UUID>;

    /** The group the client is currently subscribed to */
    groupId?: GroupId;
}

export type Socket = import("socket.io-client").Socket<{}, {}>;
export type RoomSocket = import("socket.io-client").Socket<
    RoomServerToClientEvents,
    RoomClientToServerEvents
>;
export type MessageSocket = import("socket.io-client").Socket<
    MessageServerToClientEvents,
    MessageClientToServerEvents
>;

export type UserEvents = RoomServerToClientEvents;

export interface RoomEvents {
    join: (id: UUID) => void;
    leave: (id: UUID) => void;
    recording: RecordingEvent;
}

export interface GroupEvents {
    message: (message: JsonSafe<Message>) => void;
}

/** Upload events generated by the server */
export interface UploadEvents {
    start: (from: UUID, id: RecordingId, mimeType: string) => void;
    chunk: (from: UUID, id: RecordingId, data: Buffer) => void;
    stop: (from: UUID, id: RecordingId) => void;
}

export interface PublisherEvents {
    [key: SignalId]: UserEvents;
    [key: JsonSafe<RoomId>]: RoomEvents;
    [key: JsonSafe<GroupId>]: GroupEvents;
    upload: UploadEvents;
}
